En esta iteración (Tabla \ref{table:ficha-iteracion-7}) se aborda:
\begin{itemize}
	\item Análisis y diseño de gestión y selección de perfiles de visualización.
	\item Implementación del control de acceso a la aplicación web mediante Spring Security.
	\item Configuración del entorno de ejecución de pruebas integrado en Maven.
	\item Diseño e implementación de pruebas unitarias y funcionales relativas al control de acceso, ejecución de la herramienta de visualización, notificación de selección y visualización del mapa mundial.
\end{itemize}


\subsubsection{Disciplina de análisis}

El caso de uso CdU2.2 es una funcionalidad con cierta complejidad e importancia en la herramienta. Por esta razón se ha elaborado un diagrama de casos de uso más detallado (Fig. \ref{fig:it7-profile-usecase-diagram}). Además, se facilita la descripción del escenario general para facilitar el estudiod el diagrama (Tabla \ref{table:cdu2.2-usecase-description}).

\imagenBorde{Cap5//it7-profile-usecase-diagram}{1.1}{Diagrama de casos de uso para la gestión de perfiles de visualización (CdU2.2)}{fig:it7-profile-usecase-diagram}

\begin{table}[!htbp]%
\centering
\begin{tabular}{| >{\arraybackslash}m{15cm} |}
	\hline
	\textbf{Identificador}: CdU2.2 \\
	\hline
	\textbf{Nombre}: Gestión de perfiles (Crear perfiles) \\
	\hline
	\textbf{Descripción}: Funcionalidad para que el administrador del sistema pueda configurar y crear perfiles de visualización. \\
	\hline
	\textbf{Precondiciones}: El usuario debe haber iniciado sesión en el sistema como \textit{administrador}. \\
	\hline
	\textbf{Post-condiciones}: Se crea un perfil de visualización en formato XML. \\
	\hline 
	\textbf{Escenario general}
	\vspace{-4mm}
	\begin{enumerate}
	\setlength{\itemsep}{-7.5pt}
	\setlength{\parsep}{-7.5pt}
	\setlength{\partopsep}{\itemsep}
	\setlength{\topsep}{0pt}
		\item El sistema muestra al usuario una lista de entidades y una lista de metáforas de visualización.
		\item El usuario selecciona una entidad.
		\item El sistema muestra los atributos mapeables de la entidad.
		\item El usuario selecciona una metáfora de visualización.
		\item El sistema muestra las dimensiones mapeables de la metáfora.
		\item El usuario configura los mapeos entre los atributos de la entidad y las dimensiones de la metáfora, y datos adicionales del perfil.
		\item El sistema guarda el perfil en formato XML.	\vspace{-6mm}
	\end{enumerate} 
	\\	
	\hline 
\end{tabular}
\caption{Descripción del caso de uso \textit{Gestión de perfiles (Crear perfiles)}}
\label{table:cdu2.2-usecase-description}
\end{table}

El diagrama de casos de uso y la descripción de sus escenarios no proporcionan una vista detallada de la funcionalidad, sino que muestran la interacción entre el usuario y el sistema. Para comenzar a obtener vistas más específicas, se elabora el diagrama de comunicación a partir de ambos modelos. Este diagrama ofrece una vista más detallada en cuanto a los controladores y entidades que intervienen en la ejecución de la operación.

En la figura \ref{fig:it7-profile-communication-class-diagram} se muestra el diagrama de comunicación del caso de uso CdU2.2. En él observa que la clase de control \textit{ProfileAction} actúa de fachada entre la interfaz gráfica de usuario y el resto de controladores y entidades. Esta estructura se da en todos los diagramas de comunicación de la aplicación web porque la fachada es una acción de Struts 2 y este es el fundamento del patrón MVC que implementa dicho framework.

\imagenBorde{Cap5//it7-profile-communication-class-diagram}{0.75}{Diagrama de comunicación la configuración de un perfil de visualización}{fig:it7-profile-communication-class-diagram}

También destaca la interacción con las clases de un paquete denominado \textit{motor gráfico}. Esto sucede porque la aplicación web, que actúa como contenedora del motor gráfico, debe tener cierto conocimiento sobre el mismo y, como consecuencia, dependencia. En este caso, la dependencia se encuentra sobre la clase \textit{DimensionAnnotationParser}, que proporcionará a la aplicación web la última versión de las dimensiones de las metáforas.

Con el estudio de análisis que se ha realizado durante esta disciplina, se modela el primer prototipo de la interfaz gráfica de usuario (Fig. \ref{fig:it7-configure-profile-ui}). Esta interfaz se ha diseñado siguiendo la idea del típico \textit{asistente de instalación} que permite aportar los datos de configuración paso a paso.

\imagenBorde{Cap5//it7-configure-profile-ui}{0.9}{Prototipo de la interfaz gráfica para la configuración de perfiles}{fig:it7-configure-profile-ui}

\subsubsection{Disciplina de diseño}

Se debe diseñar una arquitectura adecuada para que la aplicación tenga una organización estructural adecuada que haga posible la reutilización de código, la aplicación de patrones estructurales y de diseño, y reduzca el acoplamiento entre capas y clases.

En la figura \ref{fig:it7-webapp-package-diagram} se muestra un diagrama de paquetes que cumple con las expectativas mencionadas. A grandes rasgos se observan tres paquetes -presentación, dominio y persistencia- que se corresponden con las tres capas del \textbf{patrón MVC} (Modelo-Vista-Controlador). Dentro de cada uno de estos grandes paquetes se han modelado distintos subpaquetes que agrupan ficheros y clases de características similares. Por ejemplo, en el paquete \textit{jsp} se incluirán todas las páginsa jsp, en el paquete \textit{js} contendrá las librerías de JavaScript, etcétera.

De entre todos los subpaquetes destacan los siguientes:
\begin{itemize}
	\item \textbf{dao}, que a su vez contiene al subpaquete \textit{hibernate}. Esto indica que existirá una especificación genérica de la estructura que debe tener un fichero que implemente el \textbf{patrón DAO} (Data Access Object) y, además, existirá una implementación específica basada en Hibernate.
	\item \textbf{applet}, que presenta una asociación especial con el paquete \textit{Desglosa Graphics Engine}. Esta asociación indica que el paquete \textit{applet} contiene el componente del motor gráfico.
	\item \textbf{actions}, que contiene las acciones de Struts 2 que satisfarán los requisitos funcionales del sistema. Nótese la dependencia de este paquete con los paquetes de control, modelo, utilidades, etcétera.
	\item \textbf{interceptor}, que contiene interceptores que se implementarán para extender la funcionalidad de Struts 2 a las necesidades del sistema.
	\item \textbf{control}, en el que se incluirán todas las clases de utilidades que permiten operar con las clases de dominio.
	\item \textbf{model}, en el que se incluirán las clases de dominio.
\end{itemize}

\imagenBorde{Cap5//it7-webapp-package-diagram}{1.1}{Diagrama de paquetes de la aplicación web}{fig:it7-webapp-package-diagram}

Durante esta disciplina también se ha abordado el diseño de cuestiones más especificas, como la estructura de los perfiles de visualización. Para comenzar, se ha estudiado el tipo de información que se desea hacer persistente y la estructura del fichero XML que se escribirá cuando se cree un perfil. A continuación se detallan los nodos y atributos que conforman dicha estructura:
\begin{itemize}
	\item \textbf{profile}: es el nodo raíz de la estructura y contiene dos atributos: \textit{model}, que referencia a la metáfora de visualización, y \textit{entity}, que referencia a la entidad que se quiere visualizar.
	\item \textbf{name}: nombre del perfil.
	\item \textbf{description}: cadena de texto que describe el tipo de información que podrá visualizar el usuario por medio de este perfil.
	\item \textbf{mappings}: lista de asociaciones que contiene elementos de tipo \textit{mapping}.
	\item \textbf{mapping}: elemento que contiene la asociación entre un atributo de la entidad -\textit{entityAttr}-, una dimensión del modelo -\textit{modelAttr}-, y una lista de reglas -\textit{rule}- si procede.
	\item \textbf{constants}: lista de nodos \textit{constant} que contiene la configuración de las dimensiones del modelo que no se han asociado con ningún atributo de la entidad. El valor constante de una dimensión es tomado como su valor por defecto.
	\item \textbf{caption}: lista de nodos \textit{entry} que configura la leyenda informativa que será mostrada en la escena.
\end{itemize}

\lstinputlisting[language=XML,caption={Ejemplo de un perfil de visualización en formato XML},label=lst:profile-snippet]{snippets//profile-snippet.xml}

En el listado \ref{lst:profile-snippet} se propone un ejemplo que cumple con la estructura expuesta anteriormente. Para poder obtener un fichero de este tipo mediante la tecnología JAXB, es necesario diseñar una jerarquía de clases que represente dicha estructura (Fig \ref{fig:it7-profile-class-diagram}). Acto seguido, es necesario anotar debidamente los atributos de las clases mediante anotaciones de JAXB para que sea posible su \textit{serialización} a formato XML y su posterior escritura en un fichero..

\imagenBorde{Cap5//it7-profile-class-diagram}{1.1}{Diagrama de clases de los perfiles de de visualización}{fig:it7-profile-class-diagram}

Para finalizar, cabe destacar que cuando se desee configurar una escena a partir de un perfil de visualización, primero habrá que \textit{deserializarlo}, es decir, instanciar la jerarquía de objetos definida por la estructura de clases de la figura \ref{fig:it7-profile-class-diagram}. Acto seguido, habrá que operar con dichos objetos e instanciar las metáforas de visualización por medio del método de \textbf{reflexión}. Por último, se construirá una cadena con formato JSON que será proporcionada al motor gráfico como dato de entrada para que éste genere los gráficos.


\subsubsection{Disciplina de implementación}
\label{sec:iteracion-7-implementacion}

Para llevar a cabo la implementación del control de acceso, es necesario configurar Spring Security mediante un fichero de configuración. Se trata de un fichero XML que por convenio suele llamarse \textit{applicationContext-security.xml} (Véase Anexo \ref{anexo:applicationcontext}). Dada la gran cantidad de parámetros que se pueden incluir en este fichero, se recomienda consultar su manual de referencia \cite{homepage-spring-security-documentation} para profundizar en el tema y realizar una configuración precisa. En él destaca el bean \textit{userDetailsService}, que hace referencia a nuestra clase \textit{CustomUserDetailsService}. Además, es referenciado como \textit{proveedor de autenticación} en el bean \textit{authentication-provider}, donde se especifica la codificación de las contraseñas de usuario (md5 en este caso).

A continuación se implementan las clases correspondientes según el diseño elaborado en \ref{sec:iteracion-6-diseño}. Dada la importancia de estas clases por la inclusión de anotaciones JPA y su posibilidad de reutilización en otros proyectos, se incluye su código fuente en los anexos \ref{anexo:user}, \ref{anexo:group}, \ref{anexo:role} y \ref{anexo:customuserdetailsservice}.

El paso siguiente consiste en implementar el formulario de \textit{login} (Listado \ref{lst:login.jsp}). Éste será un formulario tradicional en el que el usuario pueda introducir su nombre y su contraseña pero, en este caso, para delegar el proceso de autenticación a Spring Security, el \textit{action} al que se enviarán los datos será \textit{j\_spring\_security\_check}. Si se produce algún error durante la autenticación, el mensaje de error será lanzado en forma de excepción y su valor será accesible por medio de la variable \textit{SPRING\_SECURITY\_LAST\_EXCEPTION.message}.

\lstinputlisting[language=Java,caption={Código fuente del fichero login.jsp para autenticación mediante Spring Security},label=lst:login.jsp]{snippets//login.txt}

Por otro lado, los menús que se muestran al usuario en la interfaz gráfica son renderizados de forma automática en función de los privilegios que posee. Esta característica se ha implementado mediante la librería \textit{struts-menu}, cuya configuración se lleva a cabo con un fichero XML (Listado \ref{lst:struts-menu}). En este fichero se especifican distintos menús los elementos que los componen. Además, en el atributo \textit{roles} se indica qué roles debe tener el usuario autenticado para que dicho menú sea renderizado y mostrado.

\lstinputlisting[language=XML,caption={Fichero de configuración de struts-menu (menu-config.xml)},label=lst:struts-menu]{..//..//desglosa-web//src//main//webapp//WEB-INF//menu-config.xml}



\subsubsection{Disciplina de pruebas}
\label{sec:iteracion-7-pruebas}

A partir de esta iteración es cuando se comienza a abordar las pruebas de la aplicación web. Así pues, el primer paso consiste en configurar Maven para poder ejecutarlas y obtener los informes correspondientes. Para comenzar, se realizará la configuración para las pruebas unitarias y, a continuación, la configuración para las pruebas funcionales.

\vspace{10mm}
\textbf{Configuración de Maven para la ejecución de pruebas unitarias}

Para llevar a cabo la implementación de pruebas es necesario editar el fichero de configuración de Maven y añadir como dependencia del proyecto la librería \textit{JUnit} (Listado \ref{lst:pom-junit}).

\begin{lstlisting}[language=XML,caption={Configuración de pom.xml para añadir JUnit como dependencia del proyecto},label=lst:pom-junit]
	<dependencies>
		...
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.8.2</version>
			<scope>test</scope>
    </dependency>
    ...
	<dependencies>
\end{lstlisting}

A continuación, y siguiendo el mismo proceso, se añadirá al proyecto la dependencia \textit{spring-test}. Gracias a esta librería, la implementación de pruebas se beneficiará de las ventajas que aporta \textit{Spring Framework}, como la \textit{inyección de dependencias}. Por tanto, de aquí en adelante, cada vez que sea necesario implementar un \textit{test suite} (Listado \ref{lst:snippet-test}), éste heredará de la clase \textit{AbstractDependencyInjectionSpringContextTests} y sobrescribirá el método \textit{getConfigLocations}, el cual devolverá un vector de cadenas en la que cada elemento se corresponde con la ruta los ficheros de configuración de Spring. De este modo, el programador podrá acceder al objeto \textit{applicationContext} desde cada uno de los \textit{test cases} y recuperar cualquier bean instanciado mediante Spring.

\begin{lstlisting}[language=Java,caption={Snippet de un TestCase implementado mediante JUnit y Spring-Test},label=lst:snippet-test]
public class ExampleActionTest extends AbstractDependencyInjectionSpringContextTests {

	@Override
	protected String[] getConfigLocations() {
		return new String[] {
			"classpath:applicationContext-resources.xml",
			"classpath:applicationContext-dao.xml",
			"classpath:applicationContext.xml"};
	}

	public void testExampleAction() throws Exception {
		ExampleAction action = new ExampleAction();
		action.setExampleDao((ExampleDAO) applicationContext.getBean("exampleDao"));
		String result = action.execute();
		assertEquals(Action.SUCCESS, result);
	}
}
\end{lstlisting}

Para que no sea necesario implementar los típicos métodos de pruebas \textit{setUp} y \textit{tearDown}, que usualmente se encargan de inicializar los datos de la base de datos con los que operarán los tests, se utilizará un plugin de Maven llamado \textbf{dbunit-maven-plugin}. Este plugin, que requiere una pequeña configuración (Listado \ref{lst:dbunit-configuration}), se encargará de conectar con la base de datos que utiliza la herramienta y volcar los datos de prueba que se hayan configurado en el fichero XML correspondiente. Este mismo proceso de inicialización se puede utilizar cuando la herramienta va a emplearse en producción.

\begin{lstlisting}[language=XML,caption={Configuración de dbunit-maven-plugin para la inicialización de la base de datos en la fase de pruebas},label=lst:dbunit-configuration]
<build>
	...
	<plugins>
		...
		<plugin>
		  <groupId>org.codehaus.mojo</groupId>
		  <artifactId>dbunit-maven-plugin</artifactId>
		  <version>1.0-beta-1</version>
		  <configuration>
		    <dataTypeFactoryName>${dbunit.dataTypeFactoryName}</dataTypeFactoryName>
		    <driver>${jdbc.driverClassName}</driver>
		    <username>${jdbc.username}</username>
		    <password>${jdbc.password}</password>
		    <url>${jdbc.url}</url>
		    <src>src/test/resources/sample-data.xml</src>
		    <type>${dbunit.operation.type}</type>
		    <schema>${dbunit.schema}</schema>
		    <skip>${maven.test.skip}</skip>
		  </configuration>
		  <executions>
		    <execution>
		      <id>test-compile</id>
		      <phase>test-compile</phase>
		      <goals>
		        <goal>operation</goal>
		      </goals>
		    </execution>
		    <execution>
		      <!-- Runs before integration tests and jetty:run-war -->
		      <id>test</id>
		      <phase>test</phase>
		      <goals>
		        <goal>operation</goal>
		      </goals>
		    </execution>
		  </executions>
		  <dependencies>
		    <dependency>
		      <groupId>${jdbc.groupId}</groupId>
		      <artifactId>${jdbc.artifactId}</artifactId>
		      <version>${jdbc.version}</version>
		    </dependency>
		  </dependencies>
		</plugin>
	</plugins>
</build>
\end{lstlisting}

Una vez que se han implementado los \textit{test suites} y sus correspondientes \textit{test cases}, Maven los ejecutará automáticamente durante el proceso de construcción del proyecto. Si algún test produce un error, el proceso de construcción será cancelado.

Un aspecto importante de la etapa de pruebas consiste conocer cuánto código ha sido probado mediante la implementación de las mismas. Para conocer este aspecto se generará su correspondiente informe mediante un plugin de Maven denominado \textit{cobertura-maven-plugin}. Este plugin no requiere configuración y deberá ser añadido en la sección \textit{reporting} del fichero pom.xml (Listado \ref{lst:pom-cobertura}).

\begin{lstlisting}[language=XML,caption={Configuración de pom.xml para añadir Cobertura como plugin de generación de informes},label=lst:pom-cobertura]
<reporting>
	...
	<plugins>
		<plugin>
			<groupId>org.codehaus.mojo</groupId>
			<artifactId>cobertura-maven-plugin</artifactId>
			<version>2.5.1</version>
		</plugin>
	</plugins>
</reporting>
\end{lstlisting}

Llegados a este punto, finaliza la configuración del entorno para la ejecución y generación de informes para las pruebas unitarias.


\vspace{7mm}
\textbf{Configuración de Maven para la ejecución de pruebas funcionales}

Las pruebas funcionales son aquellas que verifican que se satisfacen los requisitos funcionales del sistema. En este caso, se comprueba que el usuario pueda llevar a cabo las tareas para las que se desarrolla la herramienta y obtenga los resultados que corresponda en cada momento, tanto si la operación se está llevando a cabo con normalidad como si se produce algún error.

Existen varias soluciones para realizar las pruebas funcionales de una aplicación web de un modo automatizado. En este PFC se utilizará Canoo Webtest \cite{homepage-webtest}, que permite simular la interacción del usuario con la interfaz gráfica de la aplicación y comprobar la respuesta del sistema.

La implementación de los \textit{test suites} y \textit{test cases} de Canoo Webtest puede realizar mediante clases Java o ficheros XML. En caso de emplear ficheros XML, la automatización de su ejecución se realizará mediante tareas de \textbf{Ant}. No obstante, este método tiene una dificultad añadida ya que es necesario que la aplicación web se encuentre en un contenedor de servlets para que Canoo Webtest pueda comportarse como un usuario y analizar la respuesta del servidor. Para ello, será necesario realizar una compleja configuración de Maven (Véase Anexo \ref{anexo:integration-test-profile}) que instancie un contenedor de servlets (\textit{cargo-maven2-plugin}) y ejecute, mediante el plugin \textbf{maven-antrun-plugin}, las tareas que contienen las pruebas funcionales.

Para la generación de informes de las pruebas funcionales se hará uso del plugin \textbf{webtest-maven-plugin}. Este plugin, del mismo modo el empleado para la generación de informes de las pruebas unitarias, no requiere configuración y deberá ser añadido en la sección \textit{reporting} del fichero pom.xml.


\vspace{7mm}
\textbf{Diseño e implementación de pruebas unitarias y funcionales}

Una vez que se ha configurado el entorno tal y como se ha descrito en esta sección, se procede a diseñar e implementar las pruebas unitarias y funcionales.

Según la ficha de iteración (Tabla \ref{table:ficha-iteracion-7}), procede elaborar las pruebas de los CdU2.1, CdU2.9, CdU2.11 y CdU2.7. Para evitar que la sección se extienda demasiado, en este documento se sólo se incluye el proceso desarrollado en términos del CdU2.1 (control de acceso), que parte desde el diseño de los casos de prueba. En las tablas \ref{table:cdu2.1-testcase1-description}, \ref{table:cdu2.1-testcase2-description}, \ref{table:cdu2.1-testcase3-description} y \ref{table:cdu2.1-testcase4-description} se incluyen algunos de estos diseños, que se corresponden con los distintos escenarios de casos de uso definidos en la tabla \ref{table:login-usecase-description}.


\begin{table}[h]%
\centering
\begin{tabular}{| >{\arraybackslash}m{15cm} |}
	\hline
	\textbf{Caso de uso}: CdU2.1 (Control de acceso) \\
	\hline
	\textbf{Caso de prueba}: 1 \\
	\hline
	\textbf{Descripción}: El usuario desea iniciar sesión en el sistema. \\
	\hline
	\textbf{Precondiciones}: Ninguna. \\
	\hline
	\textbf{Resultado}: El usuario accede al sistema y es redirigido a la página principal. \\
	\hline 
\end{tabular}
\caption{Descripción del caso de prueba 1 para CdU2.1}
\label{table:cdu2.1-testcase1-description}
\end{table}


\begin{table}[h]%
\centering
\begin{tabular}{| >{\arraybackslash}m{15cm} |}
	\hline
	\textbf{Caso de uso}: CdU2.1 (Control de acceso) \\
	\hline
	\textbf{Caso de prueba}: 2 \\
	\hline
	\textbf{Descripción}: El usuario desea finalizar la sesión en el sistema. \\
	\hline
	\textbf{Precondiciones}: El usuario debe tener una sesión activa. \\
	\hline
	\textbf{Resultado}: El usuario es desconectado del sistema y redirigido a la página principal. \\
	\hline 
\end{tabular}
\caption{Descripción del caso de prueba 2 para CdU2.1}
\label{table:cdu2.1-testcase2-description}
\end{table}


\begin{table}[h]%
\centering
\begin{tabular}{| >{\arraybackslash}m{15cm} |}
	\hline
	\textbf{Caso de uso}: CdU2.1 (Control de acceso) \\
	\hline
	\textbf{Caso de prueba}: 3 \\
	\hline
	\textbf{Descripción}: La usuario introduce un nombre de usuario y/o contraseña incorrecto. \\
	\hline
	\textbf{Precondiciones}: Ninguna. \\
	\hline
	\textbf{Resultado}: El usuario no inicia sesión y se le muestra un mensaje de error indicando que el nombre de usuario o la contraseña son incorrectos. \\
	\hline 
\end{tabular}
\caption{Descripción del caso de prueba 3 para CdU2.1}
\label{table:cdu2.1-testcase3-description}
\end{table}

\begin{table}[h]%
\centering
\begin{tabular}{| >{\arraybackslash}m{15cm} |}
	\hline
	\textbf{Caso de uso}: CdU2.1 (Control de acceso) \\
	\hline
	\textbf{Caso de prueba}: 4 \\
	\hline
	\textbf{Descripción}: La cuenta de usuario está bloqueada \\
	\hline
	\textbf{Precondiciones}: Ninguna. \\
	\hline
	\textbf{Resultado}: El usuario no inicia sesión y se le muestra un mensaje de error indicando que la cuenta de usuario se encuentra bloqueada. \\
	\hline 
\end{tabular}
\caption{Descripción del caso de prueba 4 para CdU2.1}
\label{table:cdu2.1-testcase4-description}
\end{table}

Los casos de prueba diseñados han sido implementados mediante ficheros XML de Canoo Webtest, y su ejecución se ha automatizado mediante tareas Ant. En la figura \ref{fig:screenshot-login-testsuite} se observa una captura de pantalla del \textit{test suite} que se ha implementado. En ella, cada fichero XML se corresponde con un \textit{test case} e implementa cada uno de los casos de prueba diseñados.

\imagenBorde{Cap5//screenshot-login-testsuite}{0.7}{Captura de pantalla de la \textit{test suite} para CdU2.1}{fig:screenshot-login-testsuite}

Después de la implementación y ejecución de las \textit{suites} de pruebas, Webtest genera un informe en formato HTML. En él se pueden analizar detalladamente los casos de prueba que se han ejecutado y los resultados de ejecución. Además, en caso de producirse algún error, se indica exactamente en qué paso.

En la figura \ref{fig:screenshot-webtest-login-report-general} se facilita el informe de pruebas generado por Canoo Webtest para CdU2.1: en la parte superior se indica que se han ejecutado 7 casos de prueba; en la parte inferior se muestran detalles individuales de la ejecución de cada uno de ellos. El nombre de cada caso de prueba es un enlace que lleva al analista a una nueva página en la que puede estudiar detalladamente la ejecución del caso de prueba (Fig. \ref{fig:screenshot-webtest-login-report-admin} y \ref{fig:screenshot-webtest-login-report-locked}).

\imagenBorde{Cap5//screenshot-webtest-login-report-general}{0.55}{Informe de pruebas para CdU2.1 - vista general)}{fig:screenshot-webtest-login-report-general}

\imagenBorde{Cap5//screenshot-webtest-login-report-general}{0.55}{Informe de pruebas para CdU2.1 - caso de prueba 1 (Tabla \ref{table:cdu2.1-testcase1-description})}{fig:screenshot-webtest-login-report-admin}

\imagenBorde{Cap5//screenshot-webtest-login-report-general}{0.55}{Informe de pruebas para CdU2.1 - caso de prueba 4 (Tabla \ref{table:cdu2.1-testcase4-description})}{fig:screenshot-webtest-login-report-locked}

