\chapter{Método de trabajo}
\label{ch:metododetrabajo}

% MOISES

% Explicar cómo se ha solucionado el problema.

%\section{Metodología de desarrollo}
%\subsection{Proceso Unificado de Desarrollo (PUD)}
%\section{... ¿monolítico o en iteraciones? ...}

% MARIAN

% Cómo vamos/hemos a aplicar/aplicado el RUP para resolver el problema (enfoque práctico)

\section{Método de investigación preliminar}
\label{sec:investigacion-preliminar}

Tal y como se argumenta en la sección \ref{sec:motivacion}, este PFC se encuentra enmarcado dentro del proyecto de investigación \textbf{ORIGIN} (ORganizaciones Inteligentes Globales INnovadoras) \cite{homepage-origin}. Dada la naturaleza de dicho proyecto, ha sido necesario llevar a cabo un conjunto de reuniones entre diferentes investigadores del Grupo Alarcos \cite{homepage-alarcos}, entre los cuales se encuentran Félix Óscar García Rubio, Manuel Ángel Serrano Martin, \director{} (directora del PFC) y \autor{} (autor del PFC). El objetivo de estas reuniones ha consistido en determinar los requisitos que la herramienta debe satisfacer, así como las metáforas de visualización a desarrollar y las dimensiones a visualizar, cuyo resultado se muestra en la sección \ref{sec:arquitectura-dgs}.




\section{Proceso Unificado de Desarrollo (PUD)}
\label{sec:pud}

Debido al carácter investigador de este proyecto, por su encuadre dentro de un proyecto de I+D+i, se ha optado por utilizar una metodología de desarrollo de software genérica que permita adaptarse a este caso de estudio. Por estas razones, se ha seleccionado el \textbf{Proceso Unificado de Desarrollo} (en adelante PUD) como metodología de trabajo.

El PUD es una evolución del Proceso Unificado de Rational, que define un \textit{``conjunto de actividades necesarias para transformar los requisitos de usuario en un sistema software''}. Este método de trabajo consiste en un marco de desarrollo genérico y extensible que puede ser adaptado a organizaciones o proyectos específicos, independientemente del tamaño o área de aplicación de los mismos \cite{jac00}. Sus principales características son las siguientes:

\begin{itemize}
	\item \textbf{Dirigido por casos de uso}. Para poder desarrollar un sistema es necesario saber qué necesitan sus usuarios. Un usuario puede ser un ser humano u otro sistema que interacciona con el sistema que se está desarrollando. Las necesidades de un usuario se denominan requisitos funcionales y se representan por medio de casos de uso.
	
	Los casos de uso guían el proceso de desarrollo desde la especificación de requisitos hasta las pruebas y se utilizan para crear los modelos que permitan la construcción e implementación de los mismos. Todos los casos de uso juntos constituyen el \textbf{modelo de casos de uso}.
	
	\item \textbf{Centrado en la arquitectura}. La ingeniería informática, como cualquier otra ingeniería, elabora un diseño de la idea antes de llevarla a cabo. Este diseño, que se construye a partir del modelo de casos de uso e incluye los aspectos estáticos y dinámicos más significativos del sistema, es lo que se conoce como \textbf{arquitectura del sistema}.
	
	\item \textbf{Iterativo e incremental}. La estrategia \textit{divide et impera} (en castellano, \textit{divide y vencerás}) consiste en dividir un problema en partes más pequeñas y fáciles de resolver. El PUD (Fig. \ref{fig:mapa-conceptual-pud}) aplica esta estrategia y divide todo el ciclo de vida del software en ciclos más pequeños, que concluyen con una versión del producto, y estos a su vez en iteraciones. Cada iteración aborda un conjunto de casos de uso y produce un incremento en la funcionalidad del sistema software que se está desarrollando . Dada la importancia de seleccionar y ejecutar las iteraciones de forma planificada, éstas serán distribuidas a lo largo de 4 fases que componen un cada ciclo y abordarán, en mayor o menor medida, cada una de las disciplinas del flujo de trabajo fundamental: requisitos, análisis, diseño, implementación y pruebas.
\end{itemize}
	
\imagenBorde{Cap4//mapa-conceptual-pud}{0.5}{Mapa conceptual del PUD}{fig:mapa-conceptual-pud}


	
\subsection{Fases del Proceso Unificado de Desarrollo}

La aplicación del PUD para llevar a cabo el desarrollo de un proyecto software implica la realización de un conjunto de ciclos que -juntos- representan el ciclo de vida del proyecto en cuestión. Cada ciclo concluye con una versión entregable del sistema que incluye el software, los manuales, la documentación y los productos que se han obtenido a lo largo de las fases de las que consta. Un ciclo consta de las siguientes cuatro fases:

\begin{itemize}
		\item \textbf{Inicio}. Se define el alcance del proyecto. Para ello se lleva a cabo la captura de los requisitos que da lugar a una primera versión del modelo de casos de uso. Acto seguido se identifican los riesgos potenciales, se elabora un glosario de términos y se establece un plan de iteraciones.
		
		\item \textbf{Elaboración}. Se mejora el modelo de casos de uso y se diseña la arquitectura base del sistema. A continuación, se desarrollan los casos de uso más críticos que se identificaron en la fase de inicio y se obtiene una \textit{línea base} de la arquitectura para planificar las actividades y estimar los recursos necesarios para terminar el proyecto.
		
		\item \textbf{Construcción}. Se crea el producto en base a las dos fases anteriores.
		
		\item \textbf{Transición}. Implica la corrección de errores y \textit{bugs}, así como el mantenimiento del sistema.
\end{itemize}


\subsection{Disciplinas del flujo de trabajo fundamental}
 forma controlada y siguiendo un flujo de trabajo. Este flujo de trabajo consta de cinco etapas:
	\begin{itemize}
		\item \textbf{Requisitos}. El equipo de desarrollo y los clientes establecen comunicaciones por diferentes medios para especificar qué es lo que el usuario espera del sistema que se va a desarrollar.
		
		\item \textbf{Análisis}. Se identifican y especifican los casos de uso relevantes.
		
		\item \textbf{Diseño}. Se crea un diseño utilizando la arquitectura seleccionada como guía para tratar de dotar al sistema de las funcionalidades representadas por los casos de uso identificados en la etapa de análisis.
		
		\item \textbf{Implementación}. Se implementan las decisiones tomadas en la etapa de diseño, con el fin de construir las funcionalidades que satisfacen los casos de uso identificados en la etapa de análisis.
		
		\item \textbf{Pruebas}. Se verifica que los cambios realizados en el sistema satisfacen los casos de uso.
	\end{itemize}


\section{Patrones de diseño}


\section{Marco tecnológico}
\label{sec:marco}

%planificación, gestión, modelado y desarrollo

En esta sección se indicarán, incluyendo sus respectivos números de versión, las herramientas, frameworks y tecnologías empleadas a lo largo todo el ciclo de vida del proyecto.

\subsection{Herramientas de gestión de proyectos}
\begin{itemize}
	\item \textbf{Maven} 2.2.1: esta herramienta sirve para gestionar las dependencias y el ciclo de vida de proyectos Java. Se ha utilizado por medio de un \textit{plugin} de Eclipse denominado \textbf{m2eclipse}.
	\item \textbf{Subversion}: constituye el sistema de control de versiones que se ha empleado a lo largo del desarrollo del software.
	\item \textbf{Google Code}
\end{itemize}

\subsection{Herramientas de modelado de software y elaboración de documentación}
\begin{itemize}
	\item \textbf{MySQL Workbench} 5.2 CE: es una herramienta CASE (\textit{Computer Aided Software Engineering} o \textit{Ingeniería de Software Asistida por Computadora}) que proporciona un entorno visual para modelar bases de datos de un modo sencillo y rápido.
	\item \textbf{Visual Paradigm} 8.0: herramienta CASE utilizada en las etapas de análisis y diseño con el fin de elaborar los diagramas UML necesarios, como por ejemplo los diagramas de casos de uso, clases, secuencia, interacción, etcétera.
	\item \textbf{\LaTeX{}}: lenguaje de marcas y sistema de composición de documentos utilizado en la creación de documentos científicos y técnicos de gran calidad.
	\item \textbf{\BibTeX}: herramienta que se utiliza para gestionar la bibliografía y referencias de documentos generados con \LaTeX{}.
	\item \textbf{Inkscape} 0.48 y \textbf{GIMP} 2.6.11: son herramientas multiplataforma de dibujo que han sido utilizadas para generar las imágenes de este documento.
\end{itemize}

\subsection{Herramientas, tecnologías y frameworks de desarrollo software}
\begin{itemize}
	\item \textbf{Eclipse} EE Helios: se trata del Entorno de Desarrollo Integrado (en inglés, IDE o \textit{Integrated Development Environment}) que se ha utilizado para la implementación de los proyectos \textit{Desglosa Graphics Engine} y \textit{Desglosa Web}.
	\item \textbf{MySQL Community Server} 5.1.11: es el sistema gestor de bases de datos que se utilizará para hacer persistentes los datos que corresponda.
	\item \textbf{Apache Tomcat} 7.0.2 y \textbf{Jetty} 6.1.5: son los dos servidores web y contenedores de \textit{servlets} y páginas JSP (\textit{Java Server Pages}) que han sido utilizados tanto en el desarrollo como en el despliegue de la herramienta.
	\item \textbf{JUnit} y \textbf{Spring Test}
	\item \textbf{Canoo Webtest}
	\item \textbf{Ant}: para la ejecución de tests funcionales mediante Canoo Webtest.
	\item \textbf{Spring} 2.5.6: es un popular \textit{framework} de desarrollo de aplicaciones basadas en Java que proporciona mecanismos muy bien documentados y fáciles de usar para prácticas comunes.
	\item \textbf{Spring Security} 2.0.4: es un \textit{framework} que proporciona mecanismos de autenticación y permite implementar políticas de control de acceso a recursos.
	\item \textbf{Struts} 2.2.3: es un \textit{framework} basado en Java que permite desarrollar aplicaciones web mediante el patrón MVC (Modelo-Vista-Controlador), permitiendo así reducir el acoplamiento entre las tres capas que forman un sistema software.
	\item \textbf{Struts-Menu} 2.4.3: se trata de una biblioteca de etiquetas que permite crear menús dinámicos a partir de sus definiciones en formato XML. Además, está totalmente integrado con el sistema de autenticación del contenedor web, que en este caso es \textit{Spring Security}.
	\item \textbf{JSON-Lib} 2.4: es una librería basada en Java que permite transformar distintos tipos de estructuras de datos a formato JSON y viceversa.
	\item \textbf{Struts2-JQuery} 3.1.0: es un \textit{plugin} para el \textit{framework} Struts2 que proporciona de un modo sencillo las funcionalidades de \textbf{Ajax} y \textit{widgets} basados en el popular \textit{framework} de javascript \textbf{jQuery} 1.5.2  y \textbf{jQuery UI} 1.8.14.
	\item \textbf{Google Maps API} v2: proporciona un API que permite incorporar Google Maps en un página web y dotarlo de las funcionalidades necesarias.
	\item \textbf{Displaytag} 1.2: se trata de una librería de etiquetas mostrar y manipular tablas siguiendo el patrón MVC. Soporta operaciones tales como paginación, agrupación, ordenación, exportación, etcétera.
	\item \textbf{Sitemesh} 2.4.2: es un \textit{framework} para desarrollo de aplicaciones web basadas en Java, que se utiliza para aspectos de decoración y posicionamiento y proporcionar un \textit{look\&feel} entre las distintas páginas de un mismo sitio web. Su funcionamiento se basa en definir una página modelo en la que se define en qué lugares se insertarán los distintos contenidos.
	\item \textbf{JSP} 2.0: \textit{JavaServer Pages} es una tecnología que proporciona los medios necesarios para crear páginas con contenido web dinámico.
	\item \textbf{JSTL} 1.2: \textit{JavaServer Pages Standard Tag Library} es una librería que encapsula funcionalidades comunes que son utilizadas en el desarrollo de aplicaciones web, tales como estructuras condicionales, iteraciones, etcétera.
	\item \textbf{HTML}: \textit{HyperText Markup Language} es un lenguaje de marcas empleado en la elaboración de páginas web.
	\item \textbf{CSS}: \textit{Cascading Style Sheets} es un lenguaje que describe las características visuales de un documento escrito en un lenguaje de marcas.
	\item \textbf{JavaScript}: es un lenguaje de programación interpretado que, ejecutado en el lado del cliente, permite desarrollar contenidos web dinámicos evitando recargas innecesarias de la página. De este modo se puede lograr
	
	\item \textbf{Java Annotations}: es un método para añadir metadatos a código fuente Java. Estos metadatos podrán ser analizados en tiempo de compilación o tiempo de ejecución para proporcionar la información que se considere oportuna.
	\item \textbf{Java Reflection API}: la \textit{reflexión} es una técnica mediante la cual un programa informático puede observar y modificar su estructura y comportamiento en tiempo de ejecución. Esta técnica suele utilizarse junto con la \textbf{introspección}, que es la capacidad que poseen algunos lenguajes de programación orientados a objetos para determinar el tipo de un objeto en tiempo de ejecución.
	\item \textbf{JAXB API} 2.2.4: \textit{Java Architecture for XML Binding} es una tecnología integrada dentro de Java que permite obtener una representación XML a partir de una jerarquía de objetos Java. Este proceso de \textit{serialización} recibe los nombres de \textit{marshalling}, \textit{deflating} o \textit{serializing}. El proceso inverso, también soportado por JAX, recibe los nombres de \textit{unmarshalling}, \textit{inflating} o \textit{deserialization}.
	\item \textbf{Hibernate} 3.5.4: es un \textit{framework} de tipo ORM (Object-Relational Mapping) que permite establecer asociaciones entre clases Java y tablas de una base de datos relacional. También proporciona mecanismos para realizar consultas sobre la base de datos de un modo más abstracto que si se utilizase el lenguaje específico del sistema gestor de base de datos en cuestión.
	\item \textbf{JPA} 2.0: \textit{Java Persistence API} es un \textit{framework} de tipo ORM e integrado dentro de la plataforma de Java que nos permite interactuar con una base de datos por medio de objetos de la capa de dominio.
	\item \textbf{Java OpenGL} 2.0: es una biblioteca que hace de puente entre el lenguaje de programación Java y OpenGL. De este modo, es posible generar gráficos OpenGL a partir de una aplicación escrita en Java.
\end{itemize}
