\chapter{Método de Trabajo}
\label{ch:metododetrabajo}

% MOISES

% Explicar cómo se ha solucionado el problema.

%\section{Metodología de desarrollo}
%\subsection{Proceso Unificado de Desarrollo (PUD)}
%\section{... ¿monolítico o en iteraciones? ...}

% MARIAN

% Cómo vamos/hemos a aplicar/aplicado el RUP para resolver el problema (enfoque práctico)

\section{Método de investigación preliminar}
\label{sec:investigacion-preliminar}

Tal y como se argumenta en la sección \ref{sec:motivacion}, este PFC se encuentra enmarcado dentro del proyecto de investigación \textbf{ORIGIN} (ORganizaciones Inteligentes Globales INnovadoras) \cite{homepage-origin}. Dada la naturaleza de dicho proyecto, ha sido necesario llevar a cabo un conjunto de reuniones entre diferentes investigadores del Grupo Alarcos \cite{homepage-alarcos}, entre los cuales se encuentran Félix Óscar García Rubio, Manuel Ángel Serrano Martin, \director{} (directora del PFC) y \autor{} (autor del PFC). El objetivo de estas reuniones ha consistido en determinar los requisitos que la herramienta debe satisfacer, así como las metáforas de visualización a desarrollar y las dimensiones a visualizar, cuyo resultado se muestra en la sección \ref{sec:arquitectura-dgs}.




\section{Proceso Unificado de Desarrollo (PUD)}
\label{sec:pud}

Debido al carácter investigador de este proyecto, por su encuadre dentro de un proyecto de I+D+i, se ha optado por utilizar una metodología de desarrollo de software genérica que permita adaptarse a este caso de estudio. Por estas razones, se ha seleccionado el \textbf{Proceso Unificado de Desarrollo} (en adelante PUD) como metodología de trabajo.

El PUD es una evolución del Proceso Unificado de Rational, que define un \textit{``conjunto de actividades necesarias para transformar los requisitos de usuario en un sistema software''}. Este método de trabajo consiste en un marco de desarrollo genérico y extensible que puede ser adaptado a organizaciones o proyectos específicos, independientemente del tamaño o área de aplicación de los mismos \cite{jac00}. Sus principales características son las siguientes:

\begin{itemize}
	\item \textbf{Dirigido por casos de uso}. Para poder desarrollar un sistema es necesario saber qué necesitan sus usuarios. Un usuario puede ser un ser humano u otro sistema que interacciona con el sistema que se está desarrollando. Las necesidades de un usuario se denominan requisitos funcionales y se representan por medio de casos de uso.
	
	Los casos de uso guían el proceso de desarrollo desde la especificación de requisitos hasta las pruebas y se utilizan para crear los modelos que permitan la construcción e implementación de los mismos. Todos los casos de uso juntos constituyen el \textbf{modelo de casos de uso}.
	
	\item \textbf{Centrado en la arquitectura}. La ingeniería informática, como cualquier otra ingeniería, elabora un diseño de la idea antes de llevarla a cabo. Este diseño, que se construye a partir del modelo de casos de uso e incluye los aspectos estáticos y dinámicos más significativos del sistema, es lo que se conoce como \textbf{arquitectura del sistema}. Para diseñar una buena arquitectura hay que tener en cuenta conceptos como los \textit{patrones de diseño} y la \textit{programación contra interfaces} ya que tienen un gran impacto sobre ella y, por lo tanto, en su rendimiento, robustez, capacidad de evolución y escalabilidad.
	
	\item \textbf{Iterativo e incremental}. La estrategia \textit{divide et impera} (en castellano, \textit{divide y vencerás}) consiste en dividir un problema en partes más pequeñas y fáciles de resolver. El PUD (Fig. \ref{fig:mapa-conceptual-pud}) aplica esta estrategia y divide todo el ciclo de vida del software en ciclos más pequeños, que concluyen con una versión del producto, y estos a su vez en iteraciones. Cada iteración aborda un conjunto de casos de uso y produce un incremento en la funcionalidad del sistema software que se está desarrollando. Dada la importancia de seleccionar y ejecutar las iteraciones de forma planificada, éstas serán distribuidas a lo largo de 4 fases que componen un cada ciclo y abordarán, en mayor o menor medida, cada una de las disciplinas del flujo de trabajo fundamental: requisitos, análisis, diseño, implementación y pruebas.
\end{itemize}
	
\imagenBorde{Cap4//mapa-conceptual-pud}{0.5}{Mapa conceptual del PUD}{fig:mapa-conceptual-pud}


	
\subsection{Fases del Proceso Unificado de Desarrollo}
\label{sec:pud-fases}

La aplicación del PUD para llevar a cabo el desarrollo de un proyecto software implica la realización de un conjunto de ciclos que -juntos- representan el ciclo de vida del proyecto en cuestión. Cada ciclo concluye con una versión entregable del sistema que incluye el software, los manuales, la documentación y los productos que se han obtenido a lo largo de las cuatro fases de las que consta: inicio, elaboración, construcción y transición.

\begin{itemize}
		\item \textbf{Inicio}. Durante esta fase se define el alcance del proyecto y se identifican los riesgos principales. Esto permitirá llevar a cabo un estudio de viabilidad del sistema.
		
		Los artefactos que se obtienen a lo largo de esta fase son los siguientes:
		\begin{itemize}
			\item \textbf{Modelo de casos de uso}. Ya que se ha realizado una captura de requisitos, es posible identificar los requisitos funcionales del sistema y elaborar el diagrama de casos de uso.
			\item \textbf{Gestión del riesgo}. Se identifican y describen los posibles riesgos que puedan afectar al desarrollo del proyecto.
			\item \textbf{Glosario de términos}. Se elabora un glosario con los conceptos más relevantes del dominio en el que se está trabajando.
			\item \textbf{Plan de iteraciones}. Las iteraciones dedicadas a la fase de inicio se denominan \textit{iteraciones preliminares}. Será a partir de la fase de elaboración cuando comienza una sucesión de iteraciones en las que se describen los objetivos e hitos a alcanzar en las mismas.
		\end{itemize}
		
		\item \textbf{Elaboración}. Esta fase se compone de un pequeño conjunto de iteraciones en el cual se mejora el modelo de casos de uso y se diseña la arquitectura base del sistema. A continuación, se desarrollan los casos de uso más críticos que se identificaron en la fase de inicio y se obtiene una \textit{línea base} de la arquitectura.
		
		Los artefactos que se obtienen a lo largo de esta fase son los siguientes:
		\begin{itemize}
			\item \textbf{Modelo de casos de uso mejorado}. Se trabaja a partir del modelo de casos de uso obtenido en la fase de inicio, al cual se le añaden los requisitos funcionales que se hayan detectado a lo largo de la fase de elaboración.
			\item \textbf{Modelo de análisis}. Este modelo, sin llegar al nivel de detalle que ofrecen los modelos de diseño, ofrece una vista más formal que el modelo de casos de uso. Se compone de los diagramas de clases de análisis y diagramas de comunicación de los casos de uso más importantes.
			\item \textbf{Modelo de diseño}. Este modelo se compone por dos tipos de diagramas: estáticos, que muestran una vista estática del sistema -por ejemplo, diagramas de clases-, y dinámicos, que muestran una vista dinámica del sistema -por ejemplo, diagramas de secuencia e interacción-.
			\item \textbf{Modelo de datos}. Es una abstracción del dominio en el que se trabaja, que describe los elementos que intervienen en la resolución del problema y sus relaciones, tanto a nivel conceptual, como lógico y físico (o persistente).
		\end{itemize}
		
		\item \textbf{Construcción}. Esta fase, que utiliza como entrada todos los modelos producidos en las fases anteriores, aborda la mayor parte de la implementación de los requisitos funcionales del sistema. De manera conjunta, diseña y ejecuta las pruebas para las funcionalidades que se implementan.
		
		Los artefactos que se obtienen a lo largo de esta fase son los siguientes:
		\begin{itemize}
			\item \textbf{Modelo de diseño mejorado}. Se refina y completa el modelo de diseño obtenido en la fase de elaboración.
			\item \textbf{Modelo de implementación}. Consta de los diagramas de componentes y despliegue, que representan los elementos que participan en la ejecución del sistema (librerías, paquetes, etcétera), sus relaciones y dónde se ejecutan cada uno de ellos.
			\item \textbf{Modelo de pruebas}. Consta de los diferentes diseños de casos de prueba tanto unitarias como funcionales.
		\end{itemize}
		
		\item \textbf{Transición}. Al comienzo de esta fase se dispone una versión del producto prácticamente completa. Durante el desarrollo de la misma se completa la implementación del sistema y se refinan los modelos obtenidos en la fase de construcción. Cuando esta fase concluye se dispone de una versión del producto lista para ser entregada al cliente, junto con los manuales y documentos obtenidos a lo largo de todo el ciclo.
\end{itemize}


\subsection{Disciplinas del flujo de trabajo fundamental}

Cada una de las fases explicadas en la sección \ref{sec:pud-fases} se divide en una o varias iteraciones. Como ya se ha explicado anteriormente, una iteración aborda un conjunto de casos de uso y produce un incremento en la funcionalidad del sistema software que se está desarrollando. Esta situación se da porque cada iteración ejecuta  por completo el \textbf{flujo de trabajo fundamental}, que se compone de cinco disciplinas: requisitos, análisis, diseño, implementación y pruebas (Fig. \ref{fig:fases-pud}).

\begin{itemize}
	\item \textbf{Requisitos}. Esta disciplina, cuyo mayor grado de participación se da en las fases de inicio y elaboración, se centra en la captura e identificación de requisitos. Para ello, el equipo de desarrollo y los clientes establecen comunicaciones por diferentes medios para especificar qué es lo que se espera del sistema que se va a desarrollar.
	
	Los requisitos identificados que describen una funcionalidad del sistema se denominan \textbf{requisitos funcionales} y son descritos mediante casos de uso. Por otro lado, cualquier otra característica requerida del sistema que no forme parte de una funcionalidad, recibe el nombre de \textbf{requisito no funcional}.
		
	\item \textbf{Análisis}. Su mayor grado de participación se da en la fase de elaboración. En ella se elabora una especificación más detallada de los casos de uso tratando de obtener una comprensión más precisa de los requisitos del sistema. Por otro lado, se elabora el modelo de análisis que ofrecerá al equipo de desarrollo una vista más específica del sistema sin llegar al nivel de detalle del modelo de diseño.
		
	\item \textbf{Diseño}. Durante esta disciplina se elabora el modelo de diseño, que comienza a alejarse de los modelos conceptuales y ofrece un mayor nivel de detalle cada vez más cercano a la implementación.
		
	\item \textbf{Implementación}. Durante esta disciplina, que toma su mayor grado de participación en la fase de construcción, se implementan las decisiones tomadas en la etapa de diseño. El objetivo que se persigue consiste en construir las funcionalidades que satisfacen los casos de uso identificados en la etapa de análisis.
		
	\item \textbf{Pruebas}. Según el PUD, los componentes deben ser probados conforme son son implementados. Así pues, esta disciplina se encuentra presente en todas las fases en las que se ha llevado a cabo la implementación de alguna funcionalidad. La disciplina de pruebas tiene objetivo el diseño e implementación de pruebas unitarias y funcionales del sistema, así como de la automatización de su ejecución siempre y cuando sea posible.
\end{itemize}
	
\imagenBorde{Cap4//fases-pud}{1.0}{Grado de participación de las disciplinas del flujo de trabajo fundamental en las iteraciones del PUD}{fig:fases-pud}
	


\section{Patrones de diseño}

El desarrollo de sistemas software, en general, y sistemas software orientados a objetos, en particular, es una tarea difícil y costosa en términos económicos y temporales, entre otros. Si además se requiere que el sistema desarrollado o partes del mismo sean reutilizables, se puede convertir en un auténtico desafío.

El diseño de un software orientado a objetos requiere una abstracción y conceptualización del dominio en el que se trabaja para poder identificar los objetos relevantes y diseñar las clases que los representan. Las clases se deben diseñar con la \textbf{granularidad} adecuada, ya que un \textit{grano grueso} comprometería la reutilización de las mismas y violaría el principio de \textbf{bajo acoplamiento}, y un \textit{grano fino} aumentaría la complejidad del sistema y violaría el principio de \textbf{alta cohesión}. Además, es necesario definir interfaces, herencias y las relaciones entre clases. Todos estos factores que intervienen en el diseño de un sistema orientado a objetos han de ser específicos al contexto y, a su vez, lo suficientemente genéricos debido a razones de extensibilidad por futuros problemas o requisitos que puedan surgir.

En el diseño de sistemas software, cualquiera que sea su área de aplicación, existen problemas recurrentes que se dan una y otra vez. Por ejemplo, cuando se diseña una nueva una aplicación a menudo surge la necesidad de querer notificar a la interfaz gráfica de usuario los cambios que se producen en el estado de determinados objetos, y evitar a toda costa cualquier tipo de dependencia de la capa de dominio con la capa de presentación. Para resolver este problema existen soluciones de las que ya se conoce su eficacia y se ha comprobado que funcionan. Además, este problema y muchos otros, surgen a la hora de diseñar distintos sistemas, por lo que es fácil encontrar varias situaciones en el contexto del diseño orientado a objetos en las que se sigue un patrón en el diseño de las clases o la comunicación de los objetos.

En 1977, un arquitecto británico llamado Christopher Alexander definió el término \textbf{patrón}, en referencia a problemas relacionados al diseño de edificios y ciudades, de la siguiente manera: \textit{``cada patrón describe un problema que ocurre una y otra vez en nuestro entorno y, puede ser estudiado para descubrir la esencia de su solución, por lo que se puede utilizar esta solución un millón de veces sin repetir el estudio una segunda vez.''} \cite{Ale77}. Desde entonces surgen definiciones más directas como \textit{``un patrón es una solución recurrente para un problema recurrente en un contexto''}, \textit{``un patrón es una solución recurrente para un problema estándar''} o \textit{``un patrón resuelve un problema dentro de un contexto''} \cite{Ale79}.

A mediados de los años 90, un grupo de ingenieros informáticos que se hacían llamar \textbf{the gang-of-four} (\textit{el grupo de los cuatro}), adaptaron el término a la ingeniería del software y publicaron un conjunto de \textbf{patrones software} que proponían soluciones a problemas comunes basadas en buenas prácticas de diseño y programación. Estos patrones resuelven problemas de diseño específicos y hacen a la programación orientada a objetos de una disciplina más flexible, elegante y reutilizable. Así pues, no es coherente tratar de diseñar una solución desde cero y se recomienda crear nuevos diseños a partir de la experiencia previa \cite{gang-of-four}. La forma de capturar y transmitir experiencias para que puedan ser mejoradas y utilizadas otra vez se registra en forma de \textbf{patrones de diseño}, análogamente al modisto que diseña y guarda el patrón de un vestido.

Un patrón de diseño se compone de un nombre, una explicación del problema que pretende resolver, la solución propuesta y una evaluación que indica las ventajas e inconvenientes de su uso. La evaluación es un factor muy importante ya que incluye el impacto que tiene el uso del patrón sobre la flexibilidad, portabilidad y extensibilidad del sistema, y permite estudiar otras alternativas.

También mejoran la documentación y el mantenimiento ya que proporcionan una especificación explícita de las clases que participan, la comunicación entre objetos y su propósito y, además, son ampliamente conocidos por un gran número de diseñadores y desarrolladores.

A modo de síntesis, a continuación se enumeran las ventajas que proporciona el uso de patrones de diseño:
\begin{itemize}
	\item \textbf{Enriquecen el lenguaje de modelado}. Los patrones de diseño enriquecen los lenguajes de modelado como UML. De hecho, algunas herramientas de modelado permiten crear y aplicar patrones de diseño. Gracias a ellos, no es necesario comenzar los diseños desde cero a partir de entidades primitivas como clases e interfaces, sino que se pueden combinar en bloques y modelar desde un nivel de abstracción superior.
	\item \textbf{Mejoran la documentación}. Al utilizar patrones de diseño se están empleando -lo que los expertos consideran- buenas prácticas de diseño y programación que son ampliamente conocidas por otros diseñadores y desarrolladores.
	\item \textbf{Agilizan el diseño y la implementación}. Dado que los patrones de diseño proporcionan un nivel superior de abstracción, no es necesario comenzar el trabajo desde cero ya que fomentan la reutilización de diseños e implementaciones previas.
	\item \textbf{Aumento de la calidad}. Los patrones se basan en la experiencia previa, por lo que reducen fallos, son de eficacia probada y evitan la búsqueda de la solución a un problema que ya fue resuelto. Por lo tanto, son más correctos y robustos que una solución nueva.
	\item \textbf{Capacidad de reutilización}. Permiten reutilizar diseños y código para evitar reinventar soluciones a problemas ya resueltos.
\end{itemize}




\section{Marco tecnológico}
\label{sec:marco}

El conjunto de herramientas, tecnologías y frameworks que se ha empleado durante todo el ciclo de vida de este PFC es muy extenso. A continuación se enumeran los elementos más destacables, incluyendo una breve descripción de la misma y la versión empleada, si procede.

\subsection{Herramientas de gestión de proyectos}

En esta sección se muestran las herramientas que se serán utilizadas para la gestión de este PFC durante todo su ciclo de vida.

\subsubsection{Maven}

\textbf{Versión:} 2.2.1

Maven \cite{site:maven} es una herramienta de compartición de conocimiento y gestión de proyectos basados en tecnología Java. Maven establece un modelo (POM, en su acrónimo inglés Project Object Model) para especificar distintos aspectos del proyecto. Este modelo, que se representa en formato XML (Listado \ref{lst:pom-example}), permite a Maven gestionar distintos aspectos del ciclo de vida del proyecto, como la construcción, generación de informes y documentación, gestión de dependencias, gestión de la configuración, lanzamiento de versiones, distribución, etcétera.

Inicialmente, el objetivo de Maven consistía en conseguir que distintos proyectos de la \textbf{Fundación Apache} trabajasen de un modo común. Así, los desarrolladores podrían trabajar en cualquier proyecto sin tener que invertir tiempo en aprender aspectos específicos su construcción, ya que todos utiliza el mismo proceso. Después, esta misma idea se aplicó a distintas disciplinas como pruebas, generación de documentación, generación de informes, despliegue, etcétera.

A día de hoy muchas las comunidades, empresas y organizaciones gestionan sus proyectos a través de Maven.

Por último, destacar que la funcionalidad de Maven es cada vez más amplia gracias a la posibilidad de creación e incorporación de plugins.

\begin{lstlisting}[caption={Ejemplo de configuración de un ficher \textit{pom.xml} \cite{site:maven-getting-started}},label=lst:pom-example]
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mycompany.app</groupId>
  <artifactId>my-app</artifactId>
  <packaging>jar</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>Maven Quick Start Archetype</name>
  <url>http://maven.apache.org</url>
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
</project>
\end{lstlisting}


\subsubsection{Apache Subversion}

Apache Subversion \cite{site:apache-svn} es el sistema de control de versiones que se será empleado a lo largo de todo el ciclo de vida de este PFC. Su uso permitirá realizar un seguimiento del estado de las versiones y sus cambios, además de la integración de las partes del software (código ejecutable, documentación, etcétera) en un solo producto.


\subsubsection{Google Code Project Hosting}

Google Code Project Hosting \cite{site:google-code-project-hosting} es un servicio de alojamiento de proyectos software rápido, fiable y sencillo. Ofrece varias herramientas tales como \textit{Subversion}, \textit{Mercurial} y \textit{Git} para el control de versiones, una \textit{wiki} para la publicación de documentación, una sección de descargas, gestión de problemas (\textit{issue management}), entre otros. Además, permite consultar código fuente en un visor integrado y utilizar herramientas de revisión de código y revisión de contribuciones.


\subsection{Herramientas de modelado de software y elaboración de documentación}

En esta sección se muestran las herramientas que serán empleadas para la elaboración de la documentación del proyecto y de los distintos diagramas y modelos que sean necesarios en cada una de las fases del ciclo de vida de este PFC.


\subsubsection{MySQL Workbench}

\textbf{Versión:} 5.2 CE

MySQL Workbench \cite{site:mysql-workbench} (Fig. \ref{fig:mysq-workbench}) es una que permite diseñar, configurar y administrar bases de datos y servidores de bases de datos de un modo sencillo e intuitivo. Para ello dispone de funciones para modelado de datos, administración de usuarios, etcétera.

Una de las funcionalidades más interesantes es que permite generar el \textit{script} de instalación de la base de datos a partir del modelo EER (Entidad-Relación Extendido), el cual permite diseñar mediante una herramienta CASE (Computer Aided Software Engineering).

\imagenBorde{Cap4//mysql-workbench}{0.5}{Captura de pantalla de la herramienta MySQL Workbench 5.2 CE}{fig:mysql-workbench}


\subsubsection{Visual Paradigm for UML}

\textbf{Versión:} 8.0

Visual Paradigm (Fig. \ref{fig:visual-paradigm}) es una herramienta CASE (Computer Aided Software Engineering) profesional para modelado UML (Unified Modeling Language). Ofrece un conjunto de funcionalidades muy amplio que son necesarios para etapas como la captura de requisitos, planificación del proyecto, planificación de las pruebas, modelado de clases, modelado de datos, entre otras.

En este PFC se utilizará durante las disciplinas de análisis y diseño con el fin de elaborar los diagramas UML necesarios: casos de uso, clases de análisis, comunicación, clases de diseño, secuencia, interacción, despligue, componentes, etcétera.

\imagenBorde{Cap4//visual-paradigm}{0.5}{Captura de pantalla de la herramienta Visual Paradigm 8.0}{fig:visual-paradigm}


\subsubsection{\LaTeX{}}

\LaTeX{} \cite{site:latex} es un sistema de composición de textos de alta calidad diseñado para la creación de documentos científicos y técnicos. Además, es el estándar \textit{de facto} para la publicación de documentos científicos.

En este PFC será empleado para la elaboración de la documentación.
 
 
\subsubsection{\BibTeX}

\BibTeX \cite{site:bibtex} es, a su vez, una herramienta y un formato de fichero que se emplea para gestionar la bibliografía y referencias de documentos generados con \LaTeX{}.


\subsubsection{Inkscape y GIMP}

\textbf{Versión:} 0.48 y 2.6.11, respectivamente.

Por un lado, Inkscape es un editor de gráficos vectoriales, con capacidades similares a Adobe Illustrator y Macromedia Freehand. Por otro, GIMP (GNU Image Manipulation Program) es un programa para manipulación y edición de imágenes, con capacidades similares a Adobe Photoshop.

Se trata de dos herramientas de dibujo muy potentes, gratuitos, de código abierto y multiplataforma, que serán empleadas para la generación y manipulación de las imágenes utilizadas tanto en el software como en la elaboración de la documentación asociada.



\subsection{Herramientas, tecnologías y frameworks de desarrollo software}

\subsubsection{Eclipse IDE}

\textbf{Versión:} EE Helios

Eclipse es un IDE (Integrated Development Environment) de código abierto,
multiplataforma y ampliable en cuanto a funcionalidades mediante la incorporación de plugins.

En este PFC será utilizado para la construcción e implementación la herramienta. Además, su funcionalidad será ampliada mediante la incorporación del plugin  \textbf{m2eclipse} (m2e) \cite{site:m2e}, que proporcionará soporte integrado para Apache Maven. De este modo será más sencillo editar el fichero \textit{pom.xml}, gestionar las dependencias y construir el proyecto desde el propio IDE, entre otros.



\subsubsection{MySQL Community Server}

\textbf{Versión:} 5.1.11

MySQL Server es un SGBD (Sistema Gestor de Bases de Datos) relacional multi-hilo, multi-usuario y que soporta el lenguaje SQL (Structured Query Language). Posee una doble licencia: una GNU GPL para aquellos usuarios que decidan utilizar el software bajo los términos de la misma, y otra comercial para aquellos que quieran incorporarlo en productos privativos.


\subsubsection{Apache Tomcat}

\textbf{Versión:} 7.0.2

Se trata de un servidor web y contenedor de servlets de código abierto  que implementa las especificaciones de los servlets y JSP (JavaServer Pages) de Sun Microsystems.

Este servidor será empleado tanto en el desarrollo como en el despliegue la herramienta.


\subsubsection{Spring}

\textbf{Versión:} 2.5.6

es un popular \textit{framework} de desarrollo de aplicaciones basadas en Java que proporciona mecanismos muy bien documentados y fáciles de usar para prácticas comunes.


\subsubsection{Spring Security}

\textbf{Versión:} 2.0.4

es un \textit{framework} que proporciona mecanismos de autenticación y permite implementar políticas de control de acceso a recursos.

\subsubsection{Struts}

\textbf{Versión:} 2.2.3

es un \textit{framework} basado en Java que permite desarrollar aplicaciones web mediante el patrón MVC (Modelo-Vista-Controlador), permitiendo así reducir el acoplamiento entre las tres capas que forman un sistema software.


\subsubsection{Struts-Menu}

\textbf{Versión:} 2.4.3

se trata de una biblioteca de etiquetas que permite crear menús dinámicos a partir de sus definiciones en formato XML. Además, está totalmente integrado con el sistema de autenticación del contenedor web, que en este caso es \textit{Spring Security}.


\subsubsection{JSON-Lib}

\textbf{Versión:} 2.4

es una librería basada en Java que permite transformar distintos tipos de estructuras de datos a formato JSON y viceversa.


\subsubsection{Struts2-JQuery}

\textbf{Versión:} 3.1.0

es un \textit{plugin} para el \textit{framework} Struts2 que proporciona de un modo sencillo las funcionalidades de \textbf{Ajax} y \textit{widgets} basados en el popular \textit{framework} de javascript \textbf{jQuery} 1.5.2  y \textbf{jQuery UI} 1.8.14.


\subsubsection{JUnit}

\textbf{Versión:} 


\subsubsection{Spring Test}

\textbf{Versión:} 


\subsubsection{Canoo Webtest}

\textbf{Versión:} 


\subsubsection{Ant}

para la ejecución de tests funcionales mediante Canoo Webtest.


\subsubsection{Google Maps API}

\textbf{Versión:} v2

proporciona un API que permite incorporar Google Maps en un página web y dotarlo de las funcionalidades necesarias.


\subsubsection{Displaytag}

\textbf{Versión:} 1.2

se trata de una librería de etiquetas mostrar y manipular tablas siguiendo el patrón MVC. Soporta operaciones tales como paginación, agrupación, ordenación, exportación, etcétera.


\subsubsection{Sitemesh}

\textbf{Versión:}  2.4.2

es un \textit{framework} para desarrollo de aplicaciones web basadas en Java, que se utiliza para aspectos de decoración y posicionamiento y proporcionar un \textit{look\&feel} entre las distintas páginas de un mismo sitio web. Su funcionamiento se basa en definir una página modelo en la que se define en qué lugares se insertarán los distintos contenidos.


\subsubsection{JSP: JavaServer Pages}

\textbf{Versión:}  2.0

es una tecnología que proporciona los medios necesarios para crear páginas con contenido web dinámico.


\subsubsection{JSTL: JavaServer Pages Standard Tag Library}

\textbf{Versión:}  1.2

es una librería que encapsula funcionalidades comunes que son utilizadas en el desarrollo de aplicaciones web, tales como estructuras condicionales, iteraciones, etcétera.


\subsubsection{JavaScript}

es un lenguaje de programación interpretado que, ejecutado en el lado del cliente, permite desarrollar contenidos web dinámicos evitando recargas innecesarias de la página. De este modo se puede lograr
	


\subsubsection{Java Annotations}

es un método para añadir metadatos a código fuente Java. Estos metadatos podrán ser analizados en tiempo de compilación o tiempo de ejecución para proporcionar la información que se considere oportuna.


\subsubsection{Java Reflection API}

la \textit{reflexión} es una técnica mediante la cual un programa informático puede observar y modificar su estructura y comportamiento en tiempo de ejecución. Esta técnica suele utilizarse junto con la \textbf{introspección}, que es la capacidad que poseen algunos lenguajes de programación orientados a objetos para determinar el tipo de un objeto en tiempo de ejecución.


\subsubsection{JAXB: Java Architecture for XML Binding}

\textbf{Versión:}  2.2.4

es una tecnología integrada dentro de Java que permite obtener una representación XML a partir de una jerarquía de objetos Java. Este proceso de \textit{serialización} recibe los nombres de \textit{marshalling}, \textit{deflating} o \textit{serializing}. El proceso inverso, también soportado por JAX, recibe los nombres de \textit{unmarshalling}, \textit{inflating} o \textit{deserialization}.


\subsubsection{Hibernate}

\textbf{Versión:}  3.5.4

es un \textit{framework} de tipo ORM (Object-Relational Mapping) que permite establecer asociaciones entre clases Java y tablas de una base de datos relacional. También proporciona mecanismos para realizar consultas sobre la base de datos de un modo más abstracto que si se utilizase el lenguaje específico del sistema gestor de base de datos en cuestión.


\subsubsection{JPA: Java Persistence API}

\textbf{Versión:} 2.0

API es un \textit{framework} de tipo ORM e integrado dentro de la plataforma de Java que nos permite interactuar con una base de datos por medio de objetos de la capa de dominio.


\subsubsection{JOGL: Java binding for OpenGL}

\textbf{Versión:}  2.0

es una biblioteca que hace de puente entre el lenguaje de programación Java y OpenGL. De este modo, es posible generar gráficos OpenGL a partir de una aplicación escrita en Java.

