\chapter{Método de Trabajo}
\label{ch:metododetrabajo}

% MOISES

% Explicar cómo se ha solucionado el problema.

%\section{Metodología de desarrollo}
%\subsection{Proceso Unificado de Desarrollo (PUD)}
%\section{... ¿monolítico o en iteraciones? ...}

% MARIAN

% Cómo vamos/hemos a aplicar/aplicado el RUP para resolver el problema (enfoque práctico)

\section{Método de investigación preliminar}
\label{sec:investigacion-preliminar}

Tal y como se argumenta en la sección \ref{sec:motivacion}, este PFC se encuentra enmarcado dentro del proyecto de investigación \textbf{ORIGIN} (ORganizaciones Inteligentes Globales INnovadoras) \cite{homepage-origin}. Dada la naturaleza de dicho proyecto, ha sido necesario llevar a cabo un conjunto de reuniones entre diferentes investigadores del Grupo Alarcos \cite{homepage-alarcos}, entre los cuales se encuentran Félix Óscar García Rubio, Manuel Ángel Serrano Martin, \director{} (directora del PFC) y \autor{} (autor del PFC). El objetivo de estas reuniones ha consistido en determinar los requisitos que la herramienta debe satisfacer, así como las metáforas de visualización a desarrollar y las dimensiones a visualizar, cuyo resultado se muestra en la sección \ref{sec:arquitectura-dgs}.




\section{Proceso Unificado de Desarrollo (PUD)}
\label{sec:pud}

Debido al carácter investigador de este proyecto, por su encuadre dentro de un proyecto de I+D+i, se ha optado por utilizar una metodología de desarrollo de software genérica que permita adaptarse a este caso de estudio. Por estas razones, se ha seleccionado el \textbf{Proceso Unificado de Desarrollo} (en adelante PUD) como metodología de trabajo.

El PUD es una evolución del Proceso Unificado de Rational, que define un \textit{``conjunto de actividades necesarias para transformar los requisitos de usuario en un sistema software''}. Este método de trabajo consiste en un marco de desarrollo genérico y extensible que puede ser adaptado a organizaciones o proyectos específicos, independientemente del tamaño o área de aplicación de los mismos \cite{jac00}. Sus principales características son las siguientes:

\begin{itemize}
	\item \textbf{Dirigido por casos de uso}. Para poder desarrollar un sistema es necesario saber qué necesitan sus usuarios. Un usuario puede ser un ser humano u otro sistema que interacciona con el sistema que se está desarrollando. Las necesidades de un usuario se denominan requisitos funcionales y se representan por medio de casos de uso.
	
	Los casos de uso guían el proceso de desarrollo desde la especificación de requisitos hasta las pruebas y se utilizan para crear los modelos que permitan la construcción e implementación de los mismos. Todos los casos de uso juntos constituyen el \textbf{modelo de casos de uso}.
	
	\item \textbf{Centrado en la arquitectura}. La ingeniería informática, como cualquier otra ingeniería, elabora un diseño de la idea antes de llevarla a cabo. Este diseño, que se construye a partir del modelo de casos de uso e incluye los aspectos estáticos y dinámicos más significativos del sistema, es lo que se conoce como \textbf{arquitectura del sistema}. Para diseñar una buena arquitectura hay que tener en cuenta conceptos como los \textit{patrones de diseño} y la \textit{programación contra interfaces} ya que tienen un gran impacto sobre ella y, por lo tanto, en su rendimiento, robustez, capacidad de evolución y escalabilidad.
	
	\item \textbf{Iterativo e incremental}. La estrategia \textit{divide et impera} (en castellano, \textit{divide y vencerás}) consiste en dividir un problema en partes más pequeñas y fáciles de resolver. El PUD (Fig. \ref{fig:mapa-conceptual-pud}) aplica esta estrategia y divide todo el ciclo de vida del software en ciclos más pequeños, que concluyen con una versión del producto, y estos a su vez en iteraciones. Cada iteración aborda un conjunto de casos de uso y produce un incremento en la funcionalidad del sistema software que se está desarrollando. Dada la importancia de seleccionar y ejecutar las iteraciones de forma planificada, éstas serán distribuidas a lo largo de 4 fases que componen un cada ciclo y abordarán, en mayor o menor medida, cada una de las disciplinas del flujo de trabajo fundamental: requisitos, análisis, diseño, implementación y pruebas.
\end{itemize}
	
\imagenBorde{Cap4//mapa-conceptual-pud}{0.5}{Mapa conceptual del PUD}{fig:mapa-conceptual-pud}


	
\subsection{Fases del Proceso Unificado de Desarrollo}
\label{sec:pud-fases}

La aplicación del PUD para llevar a cabo el desarrollo de un proyecto software implica la realización de un conjunto de ciclos que -juntos- representan el ciclo de vida del proyecto en cuestión. Cada ciclo concluye con una versión entregable del sistema que incluye el software, los manuales, la documentación y los productos que se han obtenido a lo largo de las cuatro fases de las que consta: inicio, elaboración, construcción y transición.

\begin{itemize}
		\item \textbf{Inicio}. Durante esta fase se define el alcance del proyecto y se identifican los riesgos principales. Esto permitirá llevar a cabo un estudio de viabilidad del sistema.
		
		Los artefactos que se obtienen a lo largo de esta fase son los siguientes:
		\begin{itemize}
			\item \textbf{Modelo de casos de uso}. Ya que se ha realizado una captura de requisitos, es posible identificar los requisitos funcionales del sistema y elaborar el diagrama de casos de uso.
			\item \textbf{Gestión del riesgo}. Se identifican y describen los posibles riesgos que puedan afectar al desarrollo del proyecto.
			\item \textbf{Glosario de términos}. Se elabora un glosario con los conceptos más relevantes del dominio en el que se está trabajando.
			\item \textbf{Plan de iteraciones}. Las iteraciones dedicadas a la fase de inicio se denominan \textit{iteraciones preliminares}. Será a partir de la fase de elaboración cuando comienza una sucesión de iteraciones en las que se describen los objetivos e hitos a alcanzar en las mismas.
		\end{itemize}
		
		\item \textbf{Elaboración}. Esta fase se compone de un pequeño conjunto de iteraciones en el cual se mejora el modelo de casos de uso y se diseña la arquitectura base del sistema. A continuación, se desarrollan los casos de uso más críticos que se identificaron en la fase de inicio y se obtiene una \textit{línea base} de la arquitectura.
		
		Los artefactos que se obtienen a lo largo de esta fase son los siguientes:
		\begin{itemize}
			\item \textbf{Modelo de casos de uso mejorado}. Se trabaja a partir del modelo de casos de uso obtenido en la fase de inicio, al cual se le añaden los requisitos funcionales que se hayan detectado a lo largo de la fase de elaboración.
			\item \textbf{Modelo de análisis}. Este modelo, sin llegar al nivel de detalle que ofrecen los modelos de diseño, ofrece una vista más formal que el modelo de casos de uso. Se compone de los diagramas de clases de análisis y diagramas de comunicación de los casos de uso más importantes.
			\item \textbf{Modelo de diseño}. Este modelo se compone por dos tipos de diagramas: estáticos, que muestran una vista estática del sistema -por ejemplo, diagramas de clases-, y dinámicos, que muestran una vista dinámica del sistema -por ejemplo, diagramas de secuencia e interacción-.
			\item \textbf{Modelo de datos}. Es una abstracción del dominio en el que se trabaja, que describe los elementos que intervienen en la resolución del problema y sus relaciones, tanto a nivel conceptual, como lógico y físico (o persistente).
		\end{itemize}
		
		\item \textbf{Construcción}. Esta fase, que utiliza como entrada todos los modelos producidos en las fases anteriores, aborda la mayor parte de la implementación de los requisitos funcionales del sistema. De manera conjunta, diseña y ejecuta las pruebas para las funcionalidades que se implementan.
		
		Los artefactos que se obtienen a lo largo de esta fase son los siguientes:
		\begin{itemize}
			\item \textbf{Modelo de diseño mejorado}. Se refina y completa el modelo de diseño obtenido en la fase de elaboración.
			\item \textbf{Modelo de implementación}. Consta de los diagramas de componentes y despliegue, que representan los elementos que participan en la ejecución del sistema (librerías, paquetes, etcétera), sus relaciones y dónde se ejecutan cada uno de ellos.
			\item \textbf{Modelo de pruebas}. Consta de los diferentes diseños de casos de prueba tanto unitarias como funcionales.
		\end{itemize}
		
		\item \textbf{Transición}. Al comienzo de esta fase se dispone una versión del producto prácticamente completa. Durante el desarrollo de la misma se completa la implementación del sistema y se refinan los modelos obtenidos en la fase de construcción. Cuando esta fase concluye se dispone de una versión del producto lista para ser entregada al cliente, junto con los manuales y documentos obtenidos a lo largo de todo el ciclo.
\end{itemize}


\subsection{Disciplinas del flujo de trabajo fundamental}

Cada una de las fases explicadas en la sección \ref{sec:pud-fases} se divide en una o varias iteraciones. Como ya se ha explicado anteriormente, una iteración aborda un conjunto de casos de uso y produce un incremento en la funcionalidad del sistema software que se está desarrollando. Esta situación se da porque cada iteración ejecuta  por completo el \textbf{flujo de trabajo fundamental}, que se compone de cinco disciplinas: requisitos, análisis, diseño, implementación y pruebas (Fig. \ref{fig:fases-pud}).

\begin{itemize}
	\item \textbf{Requisitos}. Esta disciplina, cuyo mayor grado de participación se da en las fases de inicio y elaboración, se centra en la captura e identificación de requisitos. Para ello, el equipo de desarrollo y los clientes establecen comunicaciones por diferentes medios para especificar qué es lo que se espera del sistema que se va a desarrollar.
	
	Los requisitos identificados que describen una funcionalidad del sistema se denominan \textbf{requisitos funcionales} y son descritos mediante casos de uso. Por otro lado, cualquier otra característica requerida del sistema que no forme parte de una funcionalidad, recibe el nombre de \textbf{requisito no funcional}.
		
	\item \textbf{Análisis}. Su mayor grado de participación se da en la fase de elaboración. En ella se elabora una especificación más detallada de los casos de uso tratando de obtener una comprensión más precisa de los requisitos del sistema. Por otro lado, se elabora el modelo de análisis que ofrecerá al equipo de desarrollo una vista más específica del sistema sin llegar al nivel de detalle del modelo de diseño.
		
	\item \textbf{Diseño}. Durante esta disciplina se elabora el modelo de diseño, que comienza a alejarse de los modelos conceptuales y ofrece un mayor nivel de detalle cada vez más cercano a la implementación.
		
	\item \textbf{Implementación}. Durante esta disciplina, que toma su mayor grado de participación en la fase de construcción, se implementan las decisiones tomadas en la etapa de diseño. El objetivo que se persigue consiste en construir las funcionalidades que satisfacen los casos de uso identificados en la etapa de análisis.
		
	\item \textbf{Pruebas}. Según el PUD, los componentes deben ser probados conforme son son implementados. Así pues, esta disciplina se encuentra presente en todas las fases en las que se ha llevado a cabo la implementación de alguna funcionalidad. La disciplina de pruebas tiene objetivo el diseño e implementación de pruebas unitarias y funcionales del sistema, así como de la automatización de su ejecución siempre y cuando sea posible.
\end{itemize}
	
\imagenBorde{Cap4//fases-pud}{1.0}{Grado de participación de las disciplinas del flujo de trabajo fundamental en las iteraciones del PUD}{fig:fases-pud}
	


\section{Patrones de diseño}


\section{Marco tecnológico}
\label{sec:marco}

%planificación, gestión, modelado y desarrollo

En esta sección se indicarán, incluyendo sus respectivos números de versión, las herramientas, frameworks y tecnologías empleadas a lo largo todo el ciclo de vida del proyecto.

\subsection{Herramientas de gestión de proyectos}
\begin{itemize}
	\item \textbf{Maven} 2.2.1: esta herramienta sirve para gestionar las dependencias y el ciclo de vida de proyectos Java. Se ha utilizado por medio de un \textit{plugin} de Eclipse denominado \textbf{m2eclipse}.
	\item \textbf{Subversion}: constituye el sistema de control de versiones que se ha empleado a lo largo del desarrollo del software.
	\item \textbf{Google Code}
\end{itemize}

\subsection{Herramientas de modelado de software y elaboración de documentación}
\begin{itemize}
	\item \textbf{MySQL Workbench} 5.2 CE: es una herramienta CASE (\textit{Computer Aided Software Engineering} o \textit{Ingeniería de Software Asistida por Computadora}) que proporciona un entorno visual para modelar bases de datos de un modo sencillo y rápido.
	\item \textbf{Visual Paradigm} 8.0: herramienta CASE utilizada en las etapas de análisis y diseño con el fin de elaborar los diagramas UML necesarios, como por ejemplo los diagramas de casos de uso, clases, secuencia, interacción, etcétera.
	\item \textbf{\LaTeX{}}: lenguaje de marcas y sistema de composición de documentos utilizado en la creación de documentos científicos y técnicos de gran calidad.
	\item \textbf{\BibTeX}: herramienta que se utiliza para gestionar la bibliografía y referencias de documentos generados con \LaTeX{}.
	\item \textbf{Inkscape} 0.48 y \textbf{GIMP} 2.6.11: son herramientas multiplataforma de dibujo que han sido utilizadas para generar las imágenes de este documento.
\end{itemize}

\subsection{Herramientas, tecnologías y frameworks de desarrollo software}
\begin{itemize}
	\item \textbf{Eclipse} EE Helios: se trata del Entorno de Desarrollo Integrado (en inglés, IDE o \textit{Integrated Development Environment}) que se ha utilizado para la implementación de los proyectos \textit{Desglosa Graphics Engine} y \textit{Desglosa Web}.
	\item \textbf{MySQL Community Server} 5.1.11: es el sistema gestor de bases de datos que se utilizará para hacer persistentes los datos que corresponda.
	\item \textbf{Apache Tomcat} 7.0.2 y \textbf{Jetty} 6.1.5: son los dos servidores web y contenedores de \textit{servlets} y páginas JSP (\textit{Java Server Pages}) que han sido utilizados tanto en el desarrollo como en el despliegue de la herramienta.
	\item \textbf{JUnit} y \textbf{Spring Test}
	\item \textbf{Canoo Webtest}
	\item \textbf{Ant}: para la ejecución de tests funcionales mediante Canoo Webtest.
	\item \textbf{Spring} 2.5.6: es un popular \textit{framework} de desarrollo de aplicaciones basadas en Java que proporciona mecanismos muy bien documentados y fáciles de usar para prácticas comunes.
	\item \textbf{Spring Security} 2.0.4: es un \textit{framework} que proporciona mecanismos de autenticación y permite implementar políticas de control de acceso a recursos.
	\item \textbf{Struts} 2.2.3: es un \textit{framework} basado en Java que permite desarrollar aplicaciones web mediante el patrón MVC (Modelo-Vista-Controlador), permitiendo así reducir el acoplamiento entre las tres capas que forman un sistema software.
	\item \textbf{Struts-Menu} 2.4.3: se trata de una biblioteca de etiquetas que permite crear menús dinámicos a partir de sus definiciones en formato XML. Además, está totalmente integrado con el sistema de autenticación del contenedor web, que en este caso es \textit{Spring Security}.
	\item \textbf{JSON-Lib} 2.4: es una librería basada en Java que permite transformar distintos tipos de estructuras de datos a formato JSON y viceversa.
	\item \textbf{Struts2-JQuery} 3.1.0: es un \textit{plugin} para el \textit{framework} Struts2 que proporciona de un modo sencillo las funcionalidades de \textbf{Ajax} y \textit{widgets} basados en el popular \textit{framework} de javascript \textbf{jQuery} 1.5.2  y \textbf{jQuery UI} 1.8.14.
	\item \textbf{Google Maps API} v2: proporciona un API que permite incorporar Google Maps en un página web y dotarlo de las funcionalidades necesarias.
	\item \textbf{Displaytag} 1.2: se trata de una librería de etiquetas mostrar y manipular tablas siguiendo el patrón MVC. Soporta operaciones tales como paginación, agrupación, ordenación, exportación, etcétera.
	\item \textbf{Sitemesh} 2.4.2: es un \textit{framework} para desarrollo de aplicaciones web basadas en Java, que se utiliza para aspectos de decoración y posicionamiento y proporcionar un \textit{look\&feel} entre las distintas páginas de un mismo sitio web. Su funcionamiento se basa en definir una página modelo en la que se define en qué lugares se insertarán los distintos contenidos.
	\item \textbf{JSP} 2.0: \textit{JavaServer Pages} es una tecnología que proporciona los medios necesarios para crear páginas con contenido web dinámico.
	\item \textbf{JSTL} 1.2: \textit{JavaServer Pages Standard Tag Library} es una librería que encapsula funcionalidades comunes que son utilizadas en el desarrollo de aplicaciones web, tales como estructuras condicionales, iteraciones, etcétera.
	\item \textbf{HTML}: \textit{HyperText Markup Language} es un lenguaje de marcas empleado en la elaboración de páginas web.
	\item \textbf{CSS}: \textit{Cascading Style Sheets} es un lenguaje que describe las características visuales de un documento escrito en un lenguaje de marcas.
	\item \textbf{JavaScript}: es un lenguaje de programación interpretado que, ejecutado en el lado del cliente, permite desarrollar contenidos web dinámicos evitando recargas innecesarias de la página. De este modo se puede lograr
	
	\item \textbf{Java Annotations}: es un método para añadir metadatos a código fuente Java. Estos metadatos podrán ser analizados en tiempo de compilación o tiempo de ejecución para proporcionar la información que se considere oportuna.
	\item \textbf{Java Reflection API}: la \textit{reflexión} es una técnica mediante la cual un programa informático puede observar y modificar su estructura y comportamiento en tiempo de ejecución. Esta técnica suele utilizarse junto con la \textbf{introspección}, que es la capacidad que poseen algunos lenguajes de programación orientados a objetos para determinar el tipo de un objeto en tiempo de ejecución.
	\item \textbf{JAXB API} 2.2.4: \textit{Java Architecture for XML Binding} es una tecnología integrada dentro de Java que permite obtener una representación XML a partir de una jerarquía de objetos Java. Este proceso de \textit{serialización} recibe los nombres de \textit{marshalling}, \textit{deflating} o \textit{serializing}. El proceso inverso, también soportado por JAX, recibe los nombres de \textit{unmarshalling}, \textit{inflating} o \textit{deserialization}.
	\item \textbf{Hibernate} 3.5.4: es un \textit{framework} de tipo ORM (Object-Relational Mapping) que permite establecer asociaciones entre clases Java y tablas de una base de datos relacional. También proporciona mecanismos para realizar consultas sobre la base de datos de un modo más abstracto que si se utilizase el lenguaje específico del sistema gestor de base de datos en cuestión.
	\item \textbf{JPA} 2.0: \textit{Java Persistence API} es un \textit{framework} de tipo ORM e integrado dentro de la plataforma de Java que nos permite interactuar con una base de datos por medio de objetos de la capa de dominio.
	\item \textbf{Java OpenGL} 2.0: es una biblioteca que hace de puente entre el lenguaje de programación Java y OpenGL. De este modo, es posible generar gráficos OpenGL a partir de una aplicación escrita en Java.
\end{itemize}
